F. Build XOR on a Segment
time limit per test5 seconds
memory limit per test512 megabytes
You are given an array of ğ‘› integers ğ‘1,ğ‘2,â€¦,ğ‘ğ‘›, where all numbers are from 1 to 212âˆ’1.

You have to process ğ‘ queries. Each query is defined by three integers ğ‘™ğ‘–,ğ‘Ÿğ‘–,ğ‘¥ğ‘–: you need to find the smallest set ğ‘†={ğ‘ 1,ğ‘ 2,â€¦,ğ‘ ğ‘˜} that satisfies the following conditions:

each ğ‘ ğ‘— is equal to some element from the subarray from the ğ‘™ğ‘–-th position to the ğ‘Ÿğ‘–-th position inclusive;
ğ‘ 1âŠ•ğ‘ 2âŠ•â‹¯âŠ•ğ‘ ğ‘˜=ğ‘¥ğ‘–, where âŠ• denotes bitwise XOR.
Input
The first line contains one integer ğ‘› (2â‰¤ğ‘›â‰¤104).

The second line contains ğ‘› integers ğ‘1,ğ‘2,â€¦,ğ‘ğ‘› (1â‰¤ğ‘ğ‘–â‰¤212âˆ’1).

The third line contains one integer ğ‘ (1â‰¤ğ‘â‰¤106).

Then ğ‘ lines follow. The ğ‘–-th of them contains three integers ğ‘™ğ‘–,ğ‘Ÿğ‘–,ğ‘¥ğ‘– (1â‰¤ğ‘™ğ‘–â‰¤ğ‘Ÿğ‘–â‰¤ğ‘›; 1â‰¤ğ‘¥ğ‘–â‰¤212âˆ’1).

Output
For each query, print one integer â€” the minimum size of the required set. If such a set does not exist, print 0.

Example
inputCopy
7
3 5 4 1 7 3 1
5
1 3 1
1 4 1
1 3 2
4 7 5
1 7 8
outputCopy
2 1 3 3 0 
Note
Consider the queries from the example:

in the first query, you can choose ğ‘†={5,4};
in the second query, you can choose ğ‘†={1};
in the third query, you can choose ğ‘†={4,3,5};
in the fourth query, you can choose ğ‘†={1,3,7}.

è¿™é“é¢˜æ€ä¹ˆå†™ï¼Ÿ